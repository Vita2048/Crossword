<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crossword</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg-dark:#1e293b;
      --grid-bg:#334155;
      --cell-bg:#475569;
      --text-primary:#cbd5e1;
      --text-secondary:#94a3b8;
      --highlight-active:#facc15;
      --highlight-selected:#38bdf8;
      --color-correct:#4ade80;
      --color-revealed:#60a5fa;
    }
    body{
      font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
      background-color:var(--bg-dark);
      color:var(--text-primary);
      display:flex;
      justify-content:center;
      align-items:center;
      min-height:100vh;
      margin:0;
    }
    body.initial-screen .controls { display: none; }
    .game-container{
      width:95%; max-width:1200px;
      background:var(--grid-bg);
      padding:20px; border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.3);
    }
    header{ display:flex; justify-content:space-between; align-items:center;
      margin-bottom:20px; padding-bottom:15px; border-bottom:1px solid var(--cell-bg);}
    header h1{ font-size:1.8em; color:#fff; margin:0; }
    .controls{ display:flex; align-items:center; gap:20px; }
    .stats,.buttons{ display:flex; align-items:center; gap:15px; }
    .stat-item{ display:flex; align-items:center; gap:8px; font-size:1.05em; font-weight:500; }
    .btn{ padding:10px 20px; font-size:1em; font-weight:bold; cursor:pointer;
      border:none; border-radius:8px; transition:all .2s; }
    #new-game-btn{ background-color:var(--cell-bg); color:var(--text-primary); }
    #new-game-btn:hover{ background-color:#5a6b82; }
    #play-btn{ background-color:var(--highlight-selected); color:#111; }
    #play-btn:disabled{ opacity:.6; cursor:not-allowed; }
    .main-content{ display:flex; gap:30px; }
    #crossword-grid{ flex:1; }
    #grid-container{ display:grid; }
    .grid-cell{ width:35px; height:35px; background-color:var(--cell-bg);
      border:1px solid var(--grid-bg); position:relative; border-radius:4px; }
    .grid-cell.empty{ background-color:transparent; border:none; }
    .grid-cell.selected-word{ background-color:#5a82b0; }
    .grid-cell input{ width:100%; height:100%; text-align:center; text-transform:uppercase;
      font-size:1.5em; font-weight:bold; border:none; padding:0; margin:0;
      background-color:transparent; color:#fff; caret-color:var(--highlight-active);}
    .grid-cell input:focus{ outline:none; background-color:var(--highlight-active); color:#111; }
    .grid-cell.correct input{ color:var(--color-correct); }
    .grid-cell.revealed input{ color:var(--color-revealed); }
    .grid-cell span{ position:absolute; top:2px; left:3px; font-size:.7em; font-weight:bold;
      color:var(--text-secondary); pointer-events:none; }
    #clues-container{ width:40%; display:flex; flex-direction:column; }
    #reveal-word-btn{ background-color:var(--highlight-active); color:#111; width:100%; margin-bottom:20px; }
    #reveal-word-btn:hover:not(:disabled){ filter:brightness(1.1); }
    #reveal-word-btn:disabled{ background-color:#6c757d; cursor:not-allowed; color:#ccc; }
    .clues-list {
  overflow-y: auto;
  flex-grow: 1;
  padding-right: 10px;
  max-height: 80vh; /* add this to ensure it doesn't grow endlessly */
}

    .clues-list h3{ border-bottom:2px solid var(--highlight-selected); padding-bottom:8px; margin-bottom:10px; color:#fff; }
    .clue{ padding:8px; border-radius:4px; transition:background-color .2s; cursor:pointer; line-height:1.4; }
    .clue:hover{ background-color:var(--cell-bg); }
    .clue.selected{ background-color:var(--highlight-selected); color:#111; font-weight:bold; }
    .clue.correct{ text-decoration:line-through; color:var(--color-correct); opacity:.7; }
    .clue.revealed{ color:var(--color-revealed); font-style:italic; }
    #initial-setup, #loading-screen{ text-align:center; padding:50px 0; }
    #initial-setup .choice{ margin:10px; }
    #initial-setup .choice .btn{ padding:15px 30px; font-size:1.1em; min-width:160px; }
    #win-banner{ font-size:3em; font-weight:bold; margin:20px 0; animation:flash 1s infinite; text-align:center; }
    @keyframes flash{ 0%,100%{ color:#28a745; text-shadow:0 0 10px #28a745 } 50%{ color:#facc15; text-shadow:0 0 10px #facc15 } }
    .hidden{ display:none !important; }
  </style>
</head>
<body class="initial-screen">
  <div class="game-container">
    <header>
      <h1>Crossword</h1>
      <div class="controls">
        <div id="stats" class="stats">
          <div class="stat-item">
            <strong>Time:</strong> <span id="stopwatch">00:00</span>
          </div>
          <div class="stat-item">
            <strong>Reveals:</strong> <span id="reveal-counter">0</span>
          </div>
        </div>
        <div class="buttons">
          <button id="new-game-btn" class="btn">New Game</button>
        </div>
      </div>
    </header>

    <div id="initial-setup">
      <div style="margin-bottom:12px;font-size:1.1em;color:var(--text-secondary);">
        Load a CSV file for your crossword
      </div>
      <div class="choice">
        <input type="file" id="file-input" accept=".csv" />
      </div>
      <div class="choice">
        <button id="play-btn" class="btn" disabled>Play</button>
      </div>
    </div>

    <div id="loading-screen" class="hidden">Loading...</div>
    <div id="win-banner" class="hidden">You Win!</div>

    <div id="main-content" class="main-content hidden">
      <div id="crossword-grid"><div id="grid-container"></div></div>
      <div id="clues-container">
        <button id="reveal-word-btn" class="btn">Reveal Word</button>
        <div class="clues-list">
          <div><h3>Across</h3><div id="across-clues"></div></div>
          <div><h3>Down</h3><div id="down-clues"></div></div>
        </div>
      </div>
    </div>
  </div>

<script>
const ui = {
  initialSetup: document.getElementById('initial-setup'),
  loadingScreen: document.getElementById('loading-screen'),
  mainContent: document.getElementById('main-content'),
  gridContainer: document.getElementById('grid-container'),
  acrossClues: document.getElementById('across-clues'),
  downClues: document.getElementById('down-clues'),
  stopwatch: document.getElementById('stopwatch'),
  revealCounter: document.getElementById('reveal-counter'),
  winBanner: document.getElementById('win-banner'),
  revealWordButton: document.getElementById('reveal-word-btn'),
  newGameButton: document.getElementById('new-game-btn'),
  fileInput: document.getElementById('file-input'),
  playButton: document.getElementById('play-btn')
};

let gameState = {};
let justFocused = false;

function updateRevealButtonState(){
  const w = gameState.selectedWord;
  if (!w) { ui.revealWordButton.disabled = true; return; }
  ui.revealWordButton.disabled = gameState.correctWords.has(w.answer) || gameState.revealedWords.has(w.answer);
}

function resetGameState(){
  gameState = {
    grid: [],
    placedWords: [],
    timerInterval: null,
    startTime: null,
    reveals: 0,
    correctWords: new Set(),
    revealedWords: new Set(),
    selectedWord: null,
    lastDirection: null,
    sourceKey: null,
    sourceFile: null
  };
  ui.revealCounter.textContent = 0;
  ui.stopwatch.textContent = '00:00';
  ui.revealWordButton.disabled = true;
  ui.acrossClues.innerHTML = '';
  ui.downClues.innerHTML = '';
  ui.gridContainer.innerHTML = '';
}

ui.fileInput.addEventListener('change', () => {
  ui.playButton.disabled = !ui.fileInput.files[0];
});

ui.playButton.addEventListener('click', () => {
  const file = ui.fileInput.files[0];
  if (!file) { alert("Please select a CSV file first."); return; }
  resetGameState();
  gameState.sourceKey = 'local';
  gameState.sourceFile = file;

  document.body.classList.remove('initial-screen');
  ui.initialSetup.classList.add('hidden');
  ui.winBanner.classList.add('hidden');
  ui.mainContent.classList.add('hidden');
  ui.loadingScreen.classList.remove('hidden');

  startGame();
});

ui.newGameButton.addEventListener('click', () => {
  document.body.classList.add('initial-screen');
  ui.initialSetup.classList.remove('hidden');
  ui.mainContent.classList.add('hidden');
  ui.winBanner.classList.add('hidden');
  ui.loadingScreen.classList.add('hidden');
  ui.fileInput.value = '';
  ui.playButton.disabled = true;
  stopTimer();
  resetGameState();
});

async function fetchClues(count = 200){
  if (gameState.sourceKey === 'local' && gameState.sourceFile) {
    const text = await gameState.sourceFile.text();
    return parseCSV(text, count);
  }
  throw new Error('No source available');
}

// --- Replace parseCSV with this ---
function parseCSV(text, count){
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  let startIndex = 0;
  if (lines[0] && lines[0].toUpperCase().startsWith('ANSWER')) startIndex = 1;

  // Build full list of candidate pairs first
  const allPairs = [];
  for (let i = startIndex; i < lines.length; i++){
    const idx = lines[i].indexOf(',');
    if (idx === -1) continue;
    let answer = lines[i].slice(0, idx).trim().toUpperCase().replace(/[^A-Z]/g,'');
    let clue = lines[i].slice(idx+1).trim();
    if (!answer || !clue) continue;
    if (answer.length <= 2 || answer.length >= 15) continue;
    allPairs.push({ answer, clue });
  }

  // If there are fewer than requested, return all after shuffling
  // Shuffle full list (Fisher-Yates)
  for (let i = allPairs.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [allPairs[i], allPairs[j]] = [allPairs[j], allPairs[i]];
  }

  // Return up to `count` items from the shuffled list
  return allPairs.slice(0, Math.min(count, allPairs.length));
}

// --- Replace generateCrosswordLayout with this ---
function generateCrosswordLayout(cluePairs){
  // cluePairs already randomized by parseCSV; make a shallow copy we can mutate
  const pool = [...cluePairs];

  const gridSize = 25;
  gameState.grid = Array(gridSize).fill(null).map(()=>Array(gridSize).fill(null));
  gameState.placedWords = [];

  if (pool.length === 0) return;

  // Pick a random starting word from a wider initial window (up to first 50 or pool length)
  const initialWindow = Math.min(50, pool.length);
  const firstWordIndex = Math.floor(Math.random() * initialWindow);
  const firstWord = pool.splice(firstWordIndex, 1)[0];

  placeWord(firstWord, Math.floor(gridSize/2), Math.floor((gridSize - firstWord.answer.length)/2), 'across');

  // start counting with the already placed first word
  let placedCount = 1;
  const maxWords = 15;

  // We'll try until pool empty or we've placed maxWords or we've exhausted attempts
  let attempts = 0;
  const MAX_ATTEMPTS = pool.length * 4 + 200;

  while(pool.length > 0 && placedCount < maxWords && attempts < MAX_ATTEMPTS){
    attempts++;

    // pick a random candidate from the pool rather than shift() â€” this reduces deterministic patterns
    const idx = Math.floor(Math.random() * pool.length);
    const wordToPlace = pool.splice(idx, 1)[0];
    let placed = false;

    // Randomize the order of already placed words to vary intersections
    const placedWordsShuffled = [...gameState.placedWords];
    shuffleArray(placedWordsShuffled);

    // try to place using intersections
    for(const placedWord of placedWordsShuffled){
      for(let i=0;i<wordToPlace.answer.length && !placed;i++){
        for(let j=0;j<placedWord.answer.length && !placed;j++){
          if (wordToPlace.answer[i] === placedWord.answer[j]){
            const newDirection = placedWord.direction==='across' ? 'down' : 'across';
            const newRow = placedWord.direction==='across' ? placedWord.row - i : placedWord.row + j;
            const newCol = placedWord.direction==='across' ? placedWord.col + j : placedWord.col - i;
            if (canPlace(wordToPlace,newRow,newCol,newDirection)){
              placeWord(wordToPlace,newRow,newCol,newDirection);
              placed = true;
              placedCount++;
              break;
            }
          }
        }
      }
      if (placed) break;
    }

    // If placement failed, push wordToPlace into a small retry bucket to try later with less frequency
    if (!placed){
      // occasionally re-insert into pool to give another chance, but not always
      if (Math.random() < 0.25) pool.push(wordToPlace);
      // otherwise drop it (prevents infinite loops)
    }
  }
}

async function startGame(){
  if (gameState.timerInterval) stopTimer();
  ui.loadingScreen.classList.remove('hidden');
  try {
    const cluePairs = await fetchClues();
    if (!cluePairs.length) throw new Error('No clues loaded');
    generateCrosswordLayout(cluePairs);
    renderGrid();
    renderClues();
    const sortedWords = [...gameState.placedWords].sort((a,b)=>a.number-b.number);
    selectWord(sortedWords[0], false);
    ui.loadingScreen.classList.add('hidden');
    ui.mainContent.classList.remove('hidden');
    startTimer();
    updateRevealButtonState();
  } catch(err){
    console.error('Error starting game:', err);
    ui.loadingScreen.textContent = 'Failed to generate crossword. Check your CSV and try again.';
  }
}

function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}



function placeWord(word,row,col,direction){
  word.row=row; word.col=col; word.direction=direction;
  gameState.placedWords.push(word);
  for(let i=0;i<word.answer.length;i++){
    const r = direction==='across' ? row : row + i;
    const c = direction==='across' ? col + i : col;
    if (!gameState.grid[r][c]) gameState.grid[r][c] = { letter: word.answer[i], words: [] };
    gameState.grid[r][c].words.push(word);
  }
}

function canPlace(word,row,col,direction){
  for(let i=-1;i<=word.answer.length;i++){
    const r = direction==='across' ? row : row + i;
    const c = direction==='across' ? col + i : col;
    if (r<0 || c<0 || r>=25 || c>=25) return false;
    const isStartOrEnd = i===-1 || i===word.answer.length;
    const cell = gameState.grid[r][c];
    if (isStartOrEnd){
      if (cell) return false;
    } else {
      const crossR = direction==='across' ? r+1 : r;
      const crossC = direction==='across' ? c : c+1;
      const crossR2 = direction==='across' ? r-1 : r;
      const crossC2 = direction==='across' ? c : c-1;
      if (cell){
        if (cell.letter !== word.answer[i]) return false;
      } else {
        if (gameState.grid[crossR]?.[crossC] || gameState.grid[crossR2]?.[crossC2]) return false;
      }
    }
  }
  return true;
}

function renderGrid(){
  const bounds = getGridBounds();
  ui.gridContainer.innerHTML = '';
  ui.gridContainer.style.gridTemplateColumns = `repeat(${bounds.width}, 35px)`;
  let wordNumber = 1;
  gameState.placedWords.sort((a,b)=>a.row-b.row||a.col-b.col).forEach(w=>w.number=wordNumber++);

  for(let r=bounds.minRow;r<=bounds.maxRow;r++){
    for(let c=bounds.minCol;c<=bounds.maxCol;c++){
      const cellDiv = document.createElement('div');
      const cellData = gameState.grid[r]?.[c];
      cellDiv.className = cellData ? 'grid-cell' : 'grid-cell empty';
      if (cellData){
        const input = document.createElement('input');
        input.type='text'; input.maxLength=1;
        input.dataset.row = r; input.dataset.col = c;
        input.disabled = false;
        input.value = '';

        input.addEventListener('focus', (ev) => {
          selectWordFromCell(r,c);
          ev.target.select();
          justFocused = true;
          setTimeout(()=>{ justFocused = false; }, 0);
          updateRevealButtonState();
        });

        input.addEventListener('click', (ev) => {
          if (justFocused){ justFocused = false; return; }
          toggleDirection(r,c);
          updateRevealButtonState();
        });

        input.addEventListener('keydown', (ev) => {
          if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(ev.key)){
            ev.preventDefault();
            moveFocusByArrow(r,c,ev.key);
          } else if (ev.key === 'Backspace'){
            ev.preventDefault();
            const selected = gameState.selectedWord;
            if (!selected) return;
            const idx = getIndexInWord(selected,r,c);
            if (idx === -1) return;
            if (input.value){
              input.value = '';
              checkWordCompletion(r,c);
            } else if (idx > 0){
              focusEditableInWord(selected, idx, false);
            }
          } else if (ev.key === 'Delete'){
            ev.preventDefault();
            input.value = '';
            checkWordCompletion(r,c);
          }
        });

        input.addEventListener('input', (ev) => {
          const ch = input.value.toUpperCase().replace(/[^A-Z]/g,'');
          input.value = ch;
          if (ch) handleAdvanceAfterType(r,c);
          checkWordCompletion(r,c);
        });

        cellDiv.appendChild(input);
        const wordStart = gameState.placedWords.find(w=>w.row===r && w.col===c);
        if (wordStart){
          const numberSpan = document.createElement('span');
          numberSpan.textContent = wordStart.number;
          cellDiv.appendChild(numberSpan);
        }
      }
      ui.gridContainer.appendChild(cellDiv);
    }
  }
}

function renderClues(){
  ui.acrossClues.innerHTML = '';
  ui.downClues.innerHTML = '';
  const sortedWords = [...gameState.placedWords].sort((a,b)=>a.number-b.number);
  sortedWords.forEach(word=>{
    const clueDiv = document.createElement('div');
    clueDiv.innerHTML = `<b>${word.number}.</b> ${word.clue}`;
    clueDiv.className = 'clue';
    clueDiv.id = `clue-${word.number}`;
    clueDiv.onclick = () => { selectWord(word, true); updateRevealButtonState(); };
    (word.direction === 'across' ? ui.acrossClues : ui.downClues).appendChild(clueDiv);
  });
}
function selectWord(word, focus=false, focusIndex=null){
  if (!word) return;
  gameState.selectedWord = word;
  gameState.lastDirection = word.direction;

  document.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));
  document.querySelectorAll('.selected-word').forEach(el=>el.classList.remove('selected-word'));

  const clueEl = document.getElementById(`clue-${word.number}`);
  if (clueEl) {
    clueEl.classList.add('selected');
    // NEW: ensure the clue is visible in the scrollable list
    clueEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  for(let i=0;i<word.answer.length;i++){
    const r = word.direction==='across' ? word.row : word.row + i;
    const c = word.direction==='across' ? word.col + i : word.col;
    const input = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
    input?.parentElement.classList.add('selected-word');
  }

  if (focus){
    if (Number.isInteger(focusIndex) && focusIndex>=0 && focusIndex<word.answer.length){
      const fr = word.direction==='across' ? word.row : word.row + focusIndex;
      const fc = word.direction==='across' ? word.col + focusIndex : word.col;
      const fe = document.querySelector(`input[data-row="${fr}"][data-col="${fc}"]`);
      if (fe && !fe.disabled){ fe.focus(); updateRevealButtonState(); return; }
    }
    for(let i=0;i<word.answer.length;i++){
      const r = word.direction==='across' ? word.row : word.row + i;
      const c = word.direction==='across' ? word.col + i : word.col;
      const el = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
      if (el && !el.disabled){ el.focus(); updateRevealButtonState(); return; }
    }
  }

  updateRevealButtonState();
}


function selectWordFromCell(row,col){
  const cell = gameState.grid[row]?.[col];
  if (!cell) return;

  let words = cell.words.filter(w=>!gameState.correctWords.has(w.answer) && !gameState.revealedWords.has(w.answer));
  if (!words.length) words = cell.words;
  if (!words.length) return;

  let candidate = null;
  if (gameState.lastDirection){
    candidate = words.find(w=>w.direction===gameState.lastDirection);
  }
  if (!candidate){
    const startingWords = words.filter(w=>w.row===row && w.col===col);
    candidate = startingWords[0] || words.find(w=>w.direction==='across') || words[0];
  }

  const idx = getIndexInWord(candidate,row,col);
  selectWord(candidate, true, idx);
  gameState.lastDirection = candidate.direction;
  updateRevealButtonState();
}

function toggleDirection(row,col){
  const cell = gameState.grid[row][col];
  const currentWord = gameState.selectedWord;
  const isInCurrent = currentWord && getIndexInWord(currentWord,row,col)!==-1;
  if (isInCurrent && cell.words.length>1){
    const currentDir = currentWord.direction;
    let otherWords = cell.words.filter(w=>w.direction!==currentDir && !gameState.correctWords.has(w.answer) && !gameState.revealedWords.has(w.answer));
    if (!otherWords.length) otherWords = cell.words.filter(w=>w.direction!==currentDir);
    const otherWord = otherWords[0];
    if (otherWord){
      const idx = getIndexInWord(otherWord,row,col);
      selectWord(otherWord, true, idx);
      gameState.lastDirection = otherWord.direction;
      updateRevealButtonState();
    }
  }
}

function getIndexInWord(word,row,col){
  for(let i=0;i<word.answer.length;i++){
    const r = word.direction==='across' ? word.row : word.row + i;
    const c = word.direction==='across' ? word.col + i : word.col;
    if (r===row && c===col) return i;
  }
  return -1;
}

function focusEditableInWord(word,startIdx,forward=true){
  const step = forward ? 1 : -1;
  let i = startIdx + step;
  while(i>=0 && i<word.answer.length){
    const r = word.direction==='across' ? word.row : word.row + i;
    const c = word.direction==='across' ? word.col + i : word.col;
    const el = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
    if (el && !el.disabled){ el.focus(); return true; }
    i += step;
  }
  return false;
}

function handleAdvanceAfterType(row,col){
  const selected = gameState.selectedWord;
  if (!selected) return;
  const idx = getIndexInWord(selected,row,col);
  if (idx===-1) return;
  const moved = focusEditableInWord(selected, idx, true);
  if (!moved){
    const curInput = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
    if (curInput) curInput.focus();
  }
}

function moveFocusByArrow(row,col,key){
  let target;
  if (key==='ArrowLeft') target=[row,col-1];
  if (key==='ArrowRight') target=[row,col+1];
  if (key==='ArrowUp') target=[row-1,col];
  if (key==='ArrowDown') target=[row+1,col];
  if (!target) return;
  const el = document.querySelector(`input[data-row="${target[0]}"][data-col="${target[1]}"]`);
  if (el && !el.disabled) el.focus();
}

function checkWordCompletion(row,col){
  const cell = gameState.grid[row][col];
  if (!cell) return;
  cell.words.forEach(word=>{
    let currentGuess = '';
    for(let i=0;i<word.answer.length;i++){
      const r = word.direction==='across' ? word.row : word.row + i;
      const c = word.direction==='across' ? word.col + i : word.col;
      currentGuess += document.querySelector(`input[data-row="${r}"][data-col="${c}"]`)?.value.toUpperCase() || ' ';
    }
    if (currentGuess === word.answer && !gameState.correctWords.has(word.answer) && !gameState.revealedWords.has(word.answer)){
      gameState.correctWords.add(word.answer);
      highlightWord(word,'correct');
    }
  });
  checkWinCondition();
  updateRevealButtonState();
}

function highlightWord(word,typeClass){
  for(let i=0;i<word.answer.length;i++){
    const r = word.direction==='across' ? word.row : word.row + i;
    const c = word.direction==='across' ? word.col + i : word.col;
    const input = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
    if (input){
      input.parentElement.classList.add(typeClass);
      if (typeClass === 'correct' || typeClass === 'revealed') input.disabled = true;
    }
  }
  const clueEl = document.getElementById(`clue-${word.number}`);
  if (clueEl) clueEl.classList.add(typeClass);
}

function revealWord(){
  const word = gameState.selectedWord;
  if (!word || gameState.correctWords.has(word.answer) || gameState.revealedWords.has(word.answer)) return;
  for(let i=0;i<word.answer.length;i++){
    const r = word.direction==='across' ? word.row : word.row + i;
    const c = word.direction==='across' ? word.col + i : word.col;
    const input = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
    if (input){ input.value = word.answer[i]; input.disabled = true; }
  }
  highlightWord(word,'revealed');
  gameState.revealedWords.add(word.answer);
  gameState.reveals++;
  ui.revealCounter.textContent = gameState.reveals;
  checkWinCondition();
  updateRevealButtonState();
}

ui.revealWordButton.addEventListener('click', revealWord);

function checkWinCondition(){
  if (gameState.correctWords.size + gameState.revealedWords.size === gameState.placedWords.length){
    stopTimer();
    ui.winBanner.classList.remove('hidden');
    document.querySelectorAll('.grid-cell input').forEach(input=>input.disabled=true);
  }
}

function startTimer(){
  gameState.startTime = Date.now();
  gameState.timerInterval = setInterval(()=>{
    const elapsed = Math.floor((Date.now()-gameState.startTime)/1000);
    const minutes = String(Math.floor(elapsed/60)).padStart(2,'0');
    const seconds = String(elapsed%60).padStart(2,'0');
    ui.stopwatch.textContent = `${minutes}:${seconds}`;
  },1000);
}

function stopTimer(){ clearInterval(gameState.timerInterval); }

function getGridBounds(){
  let minR=25, maxR=0, minC=25, maxC=0;
  gameState.placedWords.forEach(w=>{
    minR = Math.min(minR, w.row);
    minC = Math.min(minC, w.col);
    maxR = Math.max(maxR, w.direction==='down' ? w.row + w.answer.length - 1 : w.row);
    maxC = Math.max(maxC, w.direction==='across' ? w.col + w.answer.length - 1 : w.col);
  });
  return { minRow: minR-1, maxRow: maxR+1, minCol: minC-1, maxCol: maxC+1, width: Math.max(1, maxC - minC + 3) };
}

resetGameState();
</script>
</body>
</html>
